# Copyright 2015 Metaswitch Networks
#
# Licensed under the Apache License, Version 2.0 (the 'License');
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an 'AS IS' BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import print_function
import socket
import functools
import logging
import json
import os
import sys

from subprocess import check_output, CalledProcessError, check_call
from netaddr import IPAddress, IPNetwork, AddrFormatError

from pycalico import netns
from pycalico.ipam import IPAMClient, SequentialAssignment
from pycalico.netns import Namespace
from pycalico.datastore_datatypes import Rules, IPPool
from pycalico.datastore import IF_PREFIX
from pycalico.datastore_errors import PoolNotFound

ETCD_AUTHORITY_ENV = 'ETCD_AUTHORITY'

ORCHESTRATOR_ID = "rkt"
HOSTNAME = socket.gethostname()
NETNS_ROOT = '/var/lib/rkt/pods/run'

# Logging configuration.
LOG_DIR = "/var/log/calico/cni"
LOG_FILENAME = "cni.log"
LOG_PATH = os.path.join(LOG_DIR, LOG_FILENAME)
_log = logging.getLogger(__name__)

# Constants for accessing environment variables. The following 
# set of variables are required by the CNI spec.
CNI_COMMAND_ENV = "CNI_COMMAND"
CNI_CONTAINERID_ENV = "CNI_CONTAINERID"
CNI_NETNS_ENV = "CNI_NETNS"
CNI_IFNAME_ENV = "CNI_IFNAME"
CNI_ARGS_ENV = "CNI_ARGS"
CNI_PATH_ENV = "CNI_PATH"

# CNI Constants
CNI_CMD_ADD = "ADD"
CNI_CMD_DELETE = "DEL"


class CniPlugin(object):
    """
    Class which encapsulates the function of a CNI 
    plugin.
    """
    def __init__(self, network_config, env, calico_config):
        self.network_config = network_config
        """
        Network config as provided in the CNI network file passed in
        via stdout.
        """

        self.env = env
        """
        Copy of the environment variable dictionary. Contains CNI_* 
        variables.
        """

        self._client = DatastoreClient()
        """
        DatastoreClient for access to the Calico datastore.
        """

        self.command = env[CNI_COMMAND_ENV]
        """
        The command to execute for this plugin instance. Required. 
        One of:
          - CNI_CMD_ADD
          - CNI_CMD_DELETE
        """

        self.container_id = env[CNI_CONTAINERID_ENV]
        """
        The container's ID in the containerizer. Required.
        """

        self.netns = env[CNI_NETNS_ENV]
        """
        Relative path to the network namespace of this container.
        """

        self.interface = env[CNI_IFNAME_ENV]
        """
        Name of the interface to create within the container.
        """

        self.cni_args = self.parse_cni_args(env[CNI_ARGS_ENV])
        """
        Dictionary of additional CNI arguments provided via
        the CNI_ARGS environment variable.
        """

        self.cni_path = env[CNI_PATH_ENV]
        """
        Path in which to search for CNI plugins.
        """

        self.network_name = network_config[TODO]
        """
        Name of the network from the provided network config file.
        """

        self.ipam_result = None
        """
        Stores the output generated by the IPAM plugin.  This is printed
        to stdout at the end of execution.
        """

        # TODO - What config do we need here and how do we get it?
        self.calico_config = calico_config

    def parse_cni_args(self, cni_args):
        """
        Parses the given CNI_ARGS string into key value pairs and 
        returns a dictionary containing the arguments.

        e.g "FOO=BAR;ABC=123" -> {"FOO": "BAR", "ABC": "123"}
        """
        # Dictionary to return.
        args_to_return = {}

        # For each arg, split at the equal sign and add to the dictionary.
        _log.debug("Parsing CNI_ARGS: %s", cni_args)
        for arg in cni_args.split(";"):
            _log.debug("\tParsing CNI_ARG: %s", arg)
            k,v = arg.split("=")
            args_to_return[k] = v
        return args_to_return

    def execute(self):
        """
        Executes this plugin.  Handles unexpected Exceptions
        in plugin execution. Returns the plugin return code.
        """
        rc = 0
        try:
            self._execute()
        except SystemExit, e:
            # SystemExit indicates an error that was handled earlier
            # in the stack.  Just set the return code.
            rc = e.code 
        except BaseException:
            # An unexpected Exception has bubbled up - catch it and
            # log it out.
            _log.exception("Unhandled Exception killed plugin")
            rc = 1
        finally:
            _log.debug("Execution complete, rc=%s", rc)
            return rc

    def _execute(self):
        """
        Priavte method to execute this plugin. Uses the given CNI_COMMAND to 
        determine which action to take.
        """
        if self.command == CNI_CMD_ADD:
            # If an add fails, we need to clean up any changes we may
            # have made.
            try:
                self.add()
            except BaseException:
                _log.exception("Failed to add container - cleaning up")
                # TODO - Clean up after a failure.
                sys.exit(1)
        else:
            assert self.command == CNI_CMD_DELETE, \
                    "Invalid command: %s" % self.command
            self.delete()

    def add(self):
        """"Handles CNI_CMD_ADD requests. 

        Configures Calico networking and prints required json to stdout.
        """
        _log.info('Configuring pod %s' % self.container_id)

        # TODO: Can we replace NETNS_ROOT with cwd?
        netns_path = '%s/%s/%s' % (NETNS_ROOT, self.container_id, netns)

        # Step 1: Assign an IP address using the given IPAM plugin.

        # Step 2: Create the Calico endpoint object.

        # Step 3: Provision the veth for this endpoint.
        
        # Step 4: Provision / set profile on the created endpoint.

        # Step 5: If all successful, print the IPAM plugin's output to stdout.
    
    def delete():
        """Handles CNI_CMD_DELETE requests.

        Remove this pod from Calico networking.
        """
        _log.info('Deleting pod %s' % container_id)

        # Step 1: Get the Calico endpoint for this workload. If it does not
        # exist, log a warning and exit successfully.

        # Step 2: The endpoint exists - remove any IP assignments. 

        # Step 3: Delete the veth interface for this endpoint. 

        # Step 4: Delete the Calico endpoint.

        # Step 5: Delete any profiles for this endpoint - TODO: This
        # is racey and needs further thinking.  For now, maybe we don't delete
        # profiles.

    def _assign_ip(self):
        """
        Assigns and returns an IPv4 address using the IPAM plugin 
        specified in the network config file.
        :return: The assigned IP address.
        """
        # TODO - Handle errors thrown by IPAM plugin
        result = self._call_ipam_plugin()
        _log.debug("IPAM plugin result: %s", result)

        try:
            # Load the response and get the assigned IP address.
            result = json.loads(result)
        except ValueError:
            _log.exception("Failed to parse IPAM response, exiting")
            sys.exit(1)

        # The request was successful.  Get the IP.
        _log.info("IPAM result: %s", result)
        return IPNetwork(result["ipv4"]["ip"])

    def _release_ip(self):
        """
        Releases the IP address for this container using the IPAM plugin 
        specified in the network config file.
        :return:
        """
        # TODO - Handle errors thrown by IPAM plugin
        _log.debug("Releasing IP address")
        try:
            result = self._call_ipam_plugin()
            _log.debug("IPAM plugin result: %s", result)
        except CalledProcessError:
            _log.exception("IPAM plugin failed to un-assign IP address.")

    def _call_ipam_plugin(self, config):
        """
        Calls through to the specified IPAM plugin.
    
        :param config: IPAM config as specified in the CNI network 
        configuration file.  A dictionary with the following form:
            {
              type: <IPAM TYPE>
            }
        :return: Response from the IPAM plugin.
        """
        # Get the plugin type and location.
        plugin_type = config['type']
        _log.debug("IPAM plugin type: %s.  Plugin directory: %s", 
                   plugin_type, self.cni_path)
    
        # Find the correct plugin based on the given type.
        plugin_path = os.path.abspath(os.path.join(plugin_dir, plugin_type))
        _log.debug("Using IPAM plugin at: %s", plugin_path)
    
        if not os.path.isfile(plugin_path):
            _log.error("Could not find IPAM plugin: %s", plugin_path)
            sys.exit(1)
    
        # Execute the plugin and return the result.
        p = Popen(plugin_path, stdin=PIPE, stdout=PIPE, stderr=PIPE)
        stdout, stderr= p.communicate(json.dumps(CONFIG))
        _log.debug("IPAM plugin output: \nstdout: %s\nstderr: %s", 
                   stdout, stderr)
        return stdout


def configure_logging(log_level=logging.INFO):
    """
    Configures logging for this file.
    """
    # If the logging directory doesn't exist, create it.
    if not os.path.exists(LOG_DIR):
        os.makedirs(LOG_DIR)

    # Create a log handler and formtter and apply to _log.
    hdlr = logging.FileHandler(filename=LOG_PATH)
    formatter = logging.Formatter('%(asctime)s %(levelname)s %(message)s')
    hdlr.setFormatter(formatter)
    _log.addHandler(hdlr)

    # Set the log level.
    _log.setLevel(log_level)


def main():
    """
    Main function - configures and runs the plugin.
    """
    # Get Calico config from config file.
    # TODO - Is this the correct way to get config in CNI? What config
    # do we need?

    # Configure logging.
    configure_logging()

    # Get the CNI environment. 
    env = os.environ.copy()

    # Read the network config file from stdin. 
    config_raw = ''.join(sys.stdin.readlines()).replace('\n', '')
    network_config = json.loads(conf_raw).copy()
    _log.debug("Loaded network config:\n%s", json.dumps(network_config, indent=2))

    # Create the plugin, passing in the network config, environment,
    # and the Calico configuration options.
    plugin = CniPlugin(network_config, env, calico_config)

    # Call the CNI plugin.
    sys.exit(plugin.execute())


if __name__ == '__main__': # pragma: no cover
    main()
